import { config } from "dotenv";
config();
import express from "express";
import bodyParser from "body-parser";
//multer use for parsing files where bodyParser not work so
import multer from "multer";
import { adminRouter } from "./routes/admin.js";
import { shopRouter } from "./routes/shop.js";
import { authRouter } from "./routes/auth.js";
import { dirname } from "path";
import { fileURLToPath } from "url";
import { getErrorPage, get500Page } from "./controllers/error.js";
// Mongoose imports
import mongoose from "mongoose";
import { User } from "./models/user.js";
//session
import session from "express-session";
//session store on mongodb
import { default as connectMongoDBSession } from "connect-mongodb-session";
//CSURF
import csurf from "csurf";
//connect-flash
import flash from "connect-flash";
//Email Js
import crypto from "crypto";

const MongoDBStore = connectMongoDBSession(session);

// mongoose connection url
const MONGODB_URL = process.env.MONGODB_URI;

const app = express();

//intialize the session store on mongodb server

const store = new MongoDBStore({
  uri: MONGODB_URL,
  collection: "sessions",
});
const port = process.env.PORT;
//CSURF
const csurfProtection = csurf();

//giving image file destination and file name using multer object

const fileStorage = multer.diskStorage({
  destination: (req, file, callback) => {
    callback(null, "images");
  },
  filename: (req, file, callback) => {
    callback(null, crypto.randomUUID() + "-" + file.originalname);
  }, //a callback which we have to call to let multer know how to name it and there, null for error

  //if we have two images with the same name, they don't overwrite each other. So we will use that file name which is auto-generated by multer or we can use any random string and then I'll concatenate it maybe with a dash in-between with the original name.
});

// only accepting .png .jpg .jpeg image files

const fileFilter = (req, file, callback) => {
  if (
    file.mimetype === "image/png" ||
    file.mimetype === "image/jpeg" ||
    file.mimetype === "image/jpg"
  ) {
    callback(null, true);
  } else {
    callback(null, false);
  }
};

export const __dirname = dirname(fileURLToPath(import.meta.url));

//connect-flash
app.use(flash());
// Middleware *(middleware position always matters)
app.use(bodyParser.urlencoded({ extended: true }));
//multer for handling file upload requests
app.use(
  multer({ storage: fileStorage, fileFilter: fileFilter }).single("image")
);
app.use(express.static("public"));
/*
By amending it to app.use('/images', express.static(path.join(__dirname, 'images'))); , what we actually do is mount a virtual "/images" path and serve the images from there, which happens to fix the issue that we stored the image path together with the name, because now the url where express will be serving the image from is http://localhost:3000/images/xyz.jpg, which is what we have in the .ejs template.

Try this: edit the record in your database by deleting the "images\" part of your imageUrl. Now app.use(express.static(path.join(__dirname, 'images'))); will be able to serve it just fine.

In the postAddProduct method, when we are saving the imageUrl like this: const imageUrl = image.path;what we could've actually done is use  const imageUrl = image.filename; this way, the "/images" virtual path would not be needed.
*/
app.use("/images", express.static("images"));

//!Session initialization

app.use(
  session({
    secret: "secret love",
    resave: false,
    saveUninitialized: false,
    store: store,
    //cookie: {
    // Set a future expiration date for the session cookie
    //expires: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000), // 30 days from now
    // },
  })
);

//CSURF middleware
app.use(csurfProtection);

//Add isAuthenticated and csrf token to all route with locals and middleware

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  res.locals.csrfToken = req.csrfToken();

  next();
});

//Authentication middleware

app.use(async (req, res, next) => {
  try {
    if (!req.session.user) {
      return next();
    }
    const user = await User.findById(req.session.user._id);

    if (!user) {
      return next();
    }

    req.user = user;
    next();
  } catch (error) {
    next(new Error(error));
  }
});

// middleware for router
app.use(shopRouter);
app.use("/admin", adminRouter);
app.use(authRouter);

app.get("/500", get500Page);

app.use(getErrorPage);

//Error Handler middleware
app.use((error, req, res, next) => {
  // console.log(error);
  // res.redirect("/500");
  res.status(500).render("500.ejs", {
    status: 500,
    message: "",
    path: "/500",
    isAuthenticated: req.session.isLoggedIn,
    error: error,
  });
});

mongoose
  .connect(MONGODB_URL)
  .then(() => {
    // Running server

    app.listen(port, () => {
      console.log(`listening on port ${port}`);
    });
  })
  .catch((error) => console.log(error));
